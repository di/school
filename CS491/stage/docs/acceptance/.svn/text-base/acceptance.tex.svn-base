\RequirePackage{fix-cm}
\documentclass[titlepage]{article}

\usepackage{fullpage}   % Use the whole page
\usepackage{lscape}
\usepackage{fancyhdr}   % Nice headers/footers
\usepackage{graphicx}   % Importing graphics
\usepackage{graphics}   % Importing graphics
\usepackage{mdwlist}    % For itemize* and enumerate*
\usepackage{hyperref}   % Hyperlink references and URLs
\usepackage{subfig}
\usepackage{appendix}
\usepackage{listings}
\usepackage{rotating}   % Rotating top row of tabular
\usepackage{multirow}   % ARRRRGH
%\usepackage{todonotes}
\usepackage{tikz}
\usepackage{pgf}
\usepackage{scalefnt}
\usepgfmodule{shapes}
\usepgfmodule{plot}
\usetikzlibrary{shapes,snakes,arrows,decorations}

% Just so we don't have to specify this twice
\newcommand\mytitle{Acceptance Test Plan}
\newcommand\version{1}

\newcommand{\testentry}[4]{
    \paragraph{#1}
    \begin{itemize}
        \item \textbf{Pre-Condition:} #2
        \item \textbf{Action:} #3
        \item \textbf{Post-Condition:} #4
    \end{itemize}
    %\vspace{0.5em}
}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    pdftitle={STAGE \mytitle, Version \version},
    pdfauthor={Dustin Ingram, Aaron Rosenfeld, Maria Kolakowska, Frank Clark}
}

% So we can number paragraphs too
\setcounter{secnumdepth}{5}

% For headers and footers
\setlength{\headheight}{15pt}
\setlength{\headsep}{25pt}
\pagestyle{fancy}
    
% Page style for the title page
\fancypagestyle{plain}{
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \renewcommand{\footrulewidth}{0pt}
}

% Page style for every other page
\fancyhf{} % clear all header and footer fields
\fancyhead[L]{STAGE}
\fancyhead[C]{\mytitle}
\fancyhead[R]{\today}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\title{\textbf{\mytitle}}
\author{
    Frank Clark \\\url{francis.j.clark@drexel.edu}
    \and Dustin Ingram \\\url{dustin.s.ingram@drexel.edu}
    \and Maria Kolakowska \\\url{maria.j.kolakowska@drexel.edu}
    \and Aaron Rosenfeld \\\url{aaron.rosenfeld@drexel.edu}
}
\date{\today\\Version \version}

\begin{document}
\pagenumbering{roman}

\begin{figure}
    \vspace{-2em}
    \centering
    \input{../common/logo.tikz}
    \vspace{-4em}
\end{figure}

\maketitle

\begin{abstract}
STAGE is an event-based simulation environment used to compare the effectiveness of different combinations of software agents, network configurations, and sensor data in real-world environments.  It is comprised of a distributed simulation engine, visualizer, and programming interface through which developers create agent software and network topologies.  Communication between virtual nodes is also simulated, providing highly realistic scenarios.
\end{abstract}

\setcounter{tocdepth}{4}
\tableofcontents
\pagebreak
%\listoffigures
%\pagebreak
\pagenumbering{arabic}

%\listoftodos

%___________________________________________________________________________

\section{Introduction%
  \label{introduction}%
}

%___________________________________________________________________________

\subsection{Objective%
  \label{objective}%
}
    This document provides the plan for completing the testing activities required for the Acceptance Test Plan of STAGE. The acceptance test plan for this system is based on the project requirements set forth in the Software Requirements Specification document.

%___________________________________________________________________________

\subsection{Structure of the Document%
    \label{structure}%
}
    \begin{itemize*}
        \item[-]Section \ref{approach} describes the overall approach to the Acceptance Test Plan process.
        \item[-]Section \ref{assumptions} describes in more detail individual issues covered or not covered by the Acceptance Test Plan process.
        \item[-]Section \ref{criteria} describes the criteria which have to be satisfied for the Acceptance Test Plan project.
        \item[-]Section \ref{participiants} describes the roles and responsibilities of the staff members involved in the Acceptance Test Plan project.
        \item[-]Section \ref{cases} describes the test cases used during the Acceptance Test Plan.
    \end{itemize*}

%___________________________________________________________________________

\subsection{References%
    \label{references}%
}
    For the STAGE project requirements, please see the Software Requirements Specification document for this project. The most recent version of this document is available at \url{http://code.google.com/p/stage/}.

%___________________________________________________________________________

\subsection{Glossary%
    \label{glossary}%
}
    \begin{description}
        \item[Test Team Leader]
            The person in charge of all the testers.
        \item[Project Leader]
            The person in charge of the whole project.
        \item[Client's Representatives]
            Client's Representatives are people who overlook the Acceptance Test Plan execution on behalf of the customers.
        \item[Software Requirements Specification]
            A Software Requirements Specification is a document which describes the behaviour of a system.
        \item[Functional Requirements]
            Functional Requirements define the internal workings of the software.
        \item[Unit Tests]
            A procedure in the software to validate that individual modules and other units of source code are working properly
        \item[Integration Test]
            Integration Test is a test phase which is employed after the Unit Tests are validated and tests how all the different modules of a software system fit and work together with each other.
        \item[System Test]
            System Test is conducted after completion of the Integration Test to evaluate the system's compliance with its specified requirements
    \end{description}

%___________________________________________________________________________

\section{Test Approach and Constraints%
    \label{approach}%
}
    This section describes the overall approach, particular techniques and testing tools which will be used during the Acceptance Test Plan of the STAGE and any constraints that may apply.

%___________________________________________________________________________

\subsection{Test Objectives%
    \label{objectives}%
}
    The Acceptance Test Plan process will prompt the client to evaluate STAGE and verify whether it performs in accordance with the client's requirements, listed in the Software Requirements Specification.

%___________________________________________________________________________

\subsection{Test Structure%
    \label{structure}%
}
    The Acceptance Test Plan will consist of a subset of test cases and methods, previously utilized in the Unit Tests, Integration Test and System Test conducted on the STAGE. The test cases will be carefully selected and agreed upon by both the developer and the client, and will allow for the most adequate verification of the functional requirements of the STAGE, as listed in the Software Requirements Document, without the extensiveness of the full-scale System Test.

    It is essential that all appropriate Unit Tests, Integration Test and the System Test were successfully performed for STAGE prior to the Acceptance Test Plan and their results were reported and presented to the client.

%___________________________________________________________________________

\section{Test Assumptions and Exclusions%
    \label{assumptions}%
}

%___________________________________________________________________________

\subsection{Introduction}
    This section provides greater details about what issues and features of STAGE will be covered by Acceptance Test Plan process, and what issues and features of STAGE will not be covered.

%___________________________________________________________________________

\subsection{Assumptions}
    It is assumed that all issues covered by the Acceptance Test Plan were also previously addressed by the Unit Tests, Integration Test and System Test of STAGE. The Acceptance Test Plan will cover:
    \begin{itemize}
        \item The functional requirements of the system listed in the Software Requirements Specification
        \item Usability of the system
    \end{itemize}

%___________________________________________________________________________

\subsection{Exclusions}
    It is assumed that all issues not covered by the Acceptance Test Plan were previously addressed by Unit Tests, Integration Tests and System Tests of STAGE. The Acceptance Test Plan will not cover:
    \begin{itemize}   
        \item The non-functional requirements of the system (except the aforementioned Usability) listed in the Software Requirements Specification
        \item Structural integrity of the source code
    \end{itemize}

%___________________________________________________________________________

\section{Entry and Exit Criteria%
    \label{criteria}%
}

%___________________________________________________________________________

\subsection{Introduction}
    This section lists the criteria which must be satisfied in order for the Acceptance Test Plan to begin, as well as the criteria which must be satisfied in order for the Acceptance Test Plan to stop.

%___________________________________________________________________________

\subsection{Entry Criteria}                                              
    The Acceptance Test Plan can be initiated after the following preconditions are met:
    \begin{itemize}
        \item Successful completion of Unit Tests, the Integration Test and a System Test.
        \item Setup and inspection of the testing environment to satisfies the System Requirements of the Software Requirements Specification.
        \item Reciept of a copy of the latest version of the Software Requirements Specification.
        \item Reciept of a copy of the latest version of the user-related documentation.
        \item Appropriate resourcing of the latest released version of STAGE.
        \item Consent of the Project Leader.
        \item Consent of the Client.
        \item Consent of the Test Team Leader.
    \end{itemize}

%___________________________________________________________________________

\subsection{Exit Criteria}
    The Acceptance Test Plan should be halted after either of the following:
    \begin{itemize}
        \item All requirements were tested without any deviation from expected behavior. (Success)
        \item At least one requirement deviated from the documented specification. (Failure)
        \item By mutual agreement between Client's Representative and the Tester, in which both parties' supervisors should be notified and the Acceptance Test Plan should be rescheduled for a later date. (Failure)
    \end{itemize}

%___________________________________________________________________________

\section{Testing Participants%
    \label{participiants}%
}

%___________________________________________________________________________

\subsection{Introduction}
    This section describes the roles and responsibilities of the staff members involved in the Acceptance Test Plan, as well as the procedure of reporting the test results and any problems that came up during testing.

%___________________________________________________________________________

\subsection{Roles and Responsibilities}
    For the Acceptance Test Plan, the following roles were assumed by the following people:
    \begin{itemize}
        \item Test Team Leader: STAGE Team Leader
        \item Client's Representative: A person in charge from the client's side who will overview the testing process.
        \item Tester: A person who will execute the use case tests.
    \end{itemize}

%___________________________________________________________________________

\subsection{Training Requirements}
    All parties involved in the Acceptance Test Plan should be familiar with the user interface of STAGE, as well as with the system documentation and the Software Requirements Specification.

%___________________________________________________________________________

\subsection{Problem Reporting}
    Any problem pointed out by either the Client's Representative or the Tester must be documented and reported to the Test Team Leader. Later the problem report will be submitted to the project Leader, and addressed during a periodic or urgent staff meeting depending on the severity of the problems.

%___________________________________________________________________________

\subsection{Progress Reporting}
    The Acceptance Test Plan Report will be compiled once, after testing process is finished by the Test Team Leader and submitted to the Project Leader.

%___________________________________________________________________________

\section{Test Cases%
    \label{cases}%
}

    The test cases are distributed in sections covering functionality elements and use cases in the Software Requirements Specification. Each of the following test cases is in the format:
    \begin{itemize}
        \item \textbf{Pre-Conditions:} Conditions needed to initiate the test case
        \item \textbf{Actions:} The actions expected form a tester
        \item \textbf{Post-Conditions:} The expected outcome of the test case
    \end{itemize}

%___________________________________________________________________________

\subsection{Functional Requirements%
    \label{functional}%
}

\subsubsection{Visualization}
    \testentry{Terrain}{
        The visualization engine is running.
    }{
        The user navigates the visualizer to any specific real-world location.
    }{
        The proper terrain for the location is shown.
    }
    \testentry{World Objects}{
        The visualization engine is running, and the user creates a scenario containing mobile and static world objects.
    }{
        The user loads and starts the created scenario.
    }{
        The visualization engine shows mobile and static world objects.
    }
    \testentry{Mobile Agents}{
        The visualization engine is running, and the user creates a scenario containing mobile nodes.
    }{
        The user loads and starts the created scenario.
    }{
        The visualization engine shows mobile nodes.
    }
    \testentry{Path-drawing}{
        The visualization engine is running, and the simulation contains an object.
    }{
        The simulator moves an object to a new location.
    }{
        The visualization engine draws the path for the object to move.
    }
    \testentry{Maximum Models}{
        The visualization engine is running, and the user creates a scenario containing 300 models.
    }{
        The user loads and starts the created scenario.
    }{
        The visualization engine shows 300 models.
    }
    \testentry{Modularity}{
        The visualization engine is running, and the user is running a simulation.
    }{
        The user terminates the execution of the visualization engine.
    }{
        The simulation continues to run.
    }
    \testentry{Timing}{
        The visualization engine is running, and the user creates a scenario containing timed events.
    }{
        The user loads and starts the created scenario.
    }{
        Movement and communication occur at real-time speeds in the visualizer.
    }
    \testentry{Viewpoints}{
        The visualization engine is running, and the user is running a simulation.
    }{
        The user executes a second visualization engine.
    }{
        The new visualization engine shows a different viewpoint than the original.
    }
    \testentry{Viewpoints}{
        The visualization engine is running.
    }{
        The user changes the viewpoint.
    }{
        The visualization engine shows a new viewpoint.
    }
    %\paragraph{Terrain} The Visualization Engine displays varying types of terrain, as defined by the environment.
    %\paragraph{World Objects} The Visualization Engine displays mobile and static world objects, as defined by the scenario.
    %\paragraph{Mobile Agents} The Visualization Engine displays mobile nodes.
    %\paragraph{Path-finding} The Visualization Engine finds the path for an object to move to a given coordinate.
    %\paragraph{Maximum Models} The Visualization Engine is able to display 300 models in a given scenario.
    %\paragraph{Modularity} The Visualization Engine component is modular, i.e. it can be removed from the framework without affecting functionality (with the exception of the visuals).
    %\paragraph{Timing} The Visualization Engine runs in real-time.
    %\paragraph{Viewpoints} The Visualization Engine is able to display the world from more than one point of view.
    %\paragraph{Viewpoints} The Visualization Engine is able to display the world from any given point of view.

%___________________________________________________________________________

\subsubsection{Simulation Engine}
    \testentry{Timing}{
        The simulation engine is running, and the user creates a scenario containing timed events.
    }{
        The user loads and starts the created scenario.
    }{
        Movement and communication occur at real-time speeds as reflected by the logs.
    }
    \testentry{Limitations of Movement}{
        The simulation engine is running, and the user creates a scenario mobile objects.
    }{
        The scenario attempts to move the object into an invalid location.
    }{
        The simulation engine moves the object as close to the invalid location as possible.
    }
    \testentry{Path-finding}{
        The simulation engine is running, and the simulation contains an object.
    }{
        The simulator moves an object to a new location.
    }{
        The visualization engine finds the path for the object to move.
    }
    \testentry{Collision Prevention}{
        The simulation engine is running, and the simulation contains mobile objects and static objects.
    }{
        The scenario attempts to move one world object into another world object.
    }{
        The simulation engine moves the object as close to the invalid location as possible.
    }
    \testentry{Maximum Models}{
        The simulation engine is running, and the user creates a scenario containing 300 models.
    }{
        The user loads and starts the created scenario.
    }{
        The simulation engine shows 300 models.
    }
    \testentry{User Intervention}{
        The simulation engine is running.
    }{
        The user inputs an event into the simulation.
    }{
        The event is reflected by the simulation engine.
    }
    %\paragraph{Timing} The Simulation Engine runs in real-time.
    %\paragraph{Limitations of Movement} The Simulation Engine limits the movement of models to specific areas or types of terrain (e.g. boats may only move on river).
    %\paragraph{Path-drawing} The Simulation Engine finds the path for an object to move to a given coordinate.
    %\paragraph{Collision Prevention} When finding a path, the Simulation Engine ensures the path will not steer an agent to navigate into world objects.
    %\paragraph{Maximum Models} The Simulation Engine keeps in memory up to 300 nodes.
    %\paragraph{User Intervention} The Simulation Engine allows for the interruption or change of events by human input.

%___________________________________________________________________________

\subsubsection{Network Definition}
    \testentry{Interfaces}{
        The user creates a scenario with a node which has an interface.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator has a node with an interface.
    }
    \testentry{Networks}{
        The user creates a scenario with a node which has an interface, connected to a network.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator has a node with an interface, connected to a network.
    }
    \testentry{Links}{
        The user creates a scenario with two nodes, each of which has an interface that are connected to one another.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator has two nodes, each of which with an interface that are connected to one another.
    }
	%\paragraph{Interfaces} The definition language specifies interfaces on each virtual node.  Specifically, each interface is described with a physical model (radio, wired, etc.) and an appropriate link-layer protocol.
	%\paragraph{Networks} The definition language specifies networks to which interfaces may interact.  Networks are described with a unique identifier and physical layer model (e.g. radio propagation model).
	%\paragraph{Links} The definition language specifies one-to-one links between interfaces.  A link is	described by a physical layer model.

%___________________________________________________________________________

\subsubsection{Scenario Definition}
    \testentry{Location}{
        The user creates a scenario with a node which has a location.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator has a node at the specified location.
    }
    \testentry{Mobility}{
        The user creates a scenario with a node which has multiple event-based locations.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator has a node which moves to the specified locations as a response to their respective events.
    }
    \testentry{Events}{
        The user creates a scenario with an agent which has an action based on the occurrence of an event.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator has a node which appropriately responds to the specified event.
    }
	%\paragraph{Location} The scenario definition language defines the location of agent and non-agent world objects.
	%\paragraph{Mobility} The scenario definition language describes the mobility or each virtual node as a function of time.
	%\paragraph{Events} Mobility is alterable as a result of events, specified in the scenario definition.
	%\paragraph{Non-node Behavior} The scenario definition language describes the movement of and events triggered by entities other than virtual nodes.

%___________________________________________________________________________

\subsubsection{Agent Framework}
    \testentry{Agent Location}{
        The user creates a scenario with a node which has an agent.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator executes the specified agent on the specified node.
    }
    \testentry{Startup}{
        The user creates a scenario with a node which has an agent and startup parameters.
    }{
        The user loads and starts the created scenario.
    }{
        The simulator executes the specified agent on the specified node and applies the startup parameters.
    }
	%\paragraph{Agent Location} The agent framework specifies on which virtual node(s) a given agent should operate.
	%\paragraph{Startup} The agent framework specifies the startup parameters of each agent.
	%\paragraph{Collection} The agent framework specifies the output parameters of each agent instance.

%___________________________________________________________________________

\subsubsection{Distribution Framework}
    \testentry{Physical Distribution}{
        The user networks multiple physical machines together and creates a scenario containing multiple nodes.
    }{
        The user executes the simulation engine, and loads and starts the created scenario.
    }{
        The simulator evenly divides the simulation of the virtual nodes across the physical machines.
    }
    \testentry{Distributed Agent Initialization}{
        The user networks multiple physical machines together and creates a scenario containing multiple nodes with agents.
    }{
        The user executes the simulation engine, and loads and starts the created scenario.
    }{
        The simulator evenly divides the simulation of the virtual nodes and their agents across the physical machines.
    }
    \testentry{Simulation Server}{
        The user networks multiple physical machines together and creates a scenario containing multiple nodes with agents.
    }{
        The user executes the simulation engine, and loads and starts the created scenario.
    }{
        The physical nodes communicate hierarchically with the simulation server.
    }
	%\paragraph{Physical Distribution} The distribution framework distributes virtual nodes evenly across physical nodes. Further, it handles the establishment and initialization of agents on their respective physical node.
	%\paragraph{Simulation Server} The distribution framework organizes physical nodes hierarchically to interact with the simulation server.

%___________________________________________________________________________

\subsubsection{Data Aggregation}
    \testentry{Data Aggregation}{
        The user executes the simulation engine, and loads and starts the created scenario.
    }{
        The user subscribes to the event channel API via an external application.
    }{
        The user's application receives events from the event channel API in real-time.
    }
    %\paragraph{Real-Time Event Subscription} The simulator has an open API channel which should be used to monitor real-time events published by the simulation.

%___________________________________________________________________________

\subsubsection{Data Storage%
  \label{data-storage}%
}
    \testentry{Scenario Definitions}{ 
        The user creates a scenario.
    }{
        The user loads and starts the created scenario.
    }{
        The simulation engine stores and parses the loaded scenario.
    }
    %\paragraph{Outside Databases} No outside database system is used for data storage, unless it is introduced by the user via the API
    %\paragraph{Scenario Definitions} Scenario definitions, including the topology and agents, are stored and parsed by the system

%___________________________________________________________________________
\pagebreak
\section{Traceability Matrix%
  \label{Traceability Matrix}%
}

Column headings represent requirement identifiers. The beginning of each row is a test case identifier.
\vspace{5pt}

%\begin{landscape}
\begin{center}
\small\addtolength{\tabcolsep}{-3pt}
\begin{tabular}{ | c || c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c |}
\hline
% & \multicolumn{27}{|c|}{Requirement Identifier} \\ \hline
& \begin{sideways}3.1.1.1\end{sideways} & \begin{sideways}3.1.1.2\end{sideways} & \begin{sideways}3.1.1.3\end{sideways} & \begin{sideways}3.1.1.4\end{sideways} & \begin{sideways}3.1.1.5\end{sideways} & \begin{sideways}3.1.1.6\end{sideways} & \begin{sideways}3.1.1.7\end{sideways} & \begin{sideways}3.1.1.8\end{sideways} & \begin{sideways}3.1.1.9\end{sideways} & \begin{sideways}3.1.2.1\end{sideways} & \begin{sideways}3.1.2.2\end{sideways} & \begin{sideways}3.1.2.3\end{sideways} & \begin{sideways}3.1.2.4\end{sideways} & \begin{sideways}3.1.2.5\end{sideways} & \begin{sideways}3.1.2.6\end{sideways} & \begin{sideways}3.1.3.1\end{sideways} & \begin{sideways}3.1.3.2\end{sideways} & \begin{sideways}3.1.3.3\end{sideways} & \begin{sideways}3.1.4.1\end{sideways} & \begin{sideways}3.1.4.2\end{sideways} & \begin{sideways}3.1.4.3\end{sideways} & \begin{sideways}3.1.5.1\end{sideways} & \begin{sideways}3.1.5.2\end{sideways} & \begin{sideways}3.1.6.1\end{sideways} & \begin{sideways}3.1.6.2\end{sideways} & \begin{sideways}3.1.7.1\end{sideways} & \begin{sideways}3.1.8.2\end{sideways} \\ \hline \hline
  6.1.1.1 & x &&&&&&&&&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.2 && x &&&&&&&&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.3 &&& x &&&&&&&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.4 &&&& x &&&&&&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.5 &&&&& x &&&&&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.6 &&&&&& x &&&&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.7 &&&&&&& x &&&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.8 &&&&&&&& x &&&&&&&&&&&&&&&&&&& \\ \hline
  6.1.1.9 &&&&&&&&& x &&&&&&&&&&&&&&&&&& \\ \hline
  6.1.2.1 &&&&&&&&&& x &&&&&&&&&&&&&&&&& \\ \hline
  6.1.2.2 &&&&&&&&&&& x &&&&&&&&&&&&&&&& \\ \hline
  6.1.2.3 &&&&&&&&&&&& x &&&&&&&&&&&&&&& \\ \hline
  6.1.2.4 &&&&&&&&&&&&& x &&&&&&&&&&&&&& \\ \hline
  6.1.2.5 &&&&&&&&&&&&&& x &&&&&&&&&&&&& \\ \hline
  6.1.2.6 &&&&&&&&&&&&&&& x &&&&&&&&&&&& \\ \hline
  6.1.3.1 &&&&&&&&&&&&&&&& x &&&&&&&&&&& \\ \hline
  6.1.3.2 &&&&&&&&&&&&&&&&& x &&&&&&&&&& \\ \hline
  6.1.3.3 &&&&&&&&&&&&&&&&&& x &&&&&&&&& \\ \hline
  6.1.4.1 &&&&&&&&&&&&&&&&&&& x &&&&&&&& \\ \hline
  6.1.4.2 &&&&&&&&&&&&&&&&&&&& x &&&&&&& \\ \hline
  6.1.4.3 &&&&&&&&&&&&&&&&&&&&& x &&&&&& \\ \hline
  6.1.5.1 &&&&&&&&&&&&&&&&&&&&&& x &&&&& \\ \hline
  6.1.5.2 &&&&&&&&&&&&&&&&&&&&&&& x &&&& \\ \hline
  6.1.6.1 &&&&&&&&&&&&&&&&&&&&&&&& x &&& \\ \hline
  %6.1.6.2 &&&&&&&&&&&   &&& \\ \hline
  6.1.6.3 &&&&&&&&&&&&&&&&&&&&&&&&& x && \\ \hline
  6.1.7.1 &&&&&&&&&&&&&&&&&&&&&&&&&& x & \\ \hline
  6.1.8.1 &&&&&&&&&&&&&&&&&&&&&&&&&&& x  \\ \hline
\end{tabular}
\end{center}

\pagebreak
\appendix
\pagebreak

\end{document}
