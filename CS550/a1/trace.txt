T/GNU Scheme running under MacOSX
Type `^C' (control-C) followed by `H' to obtain information about interrupts.

Copyright (C) 2011 Massachusetts Institute of Technology
This is free software; see the source for copying conditions. There is NO
warranty;
not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Image saved on Thursday November 10, 2011 at 5:26:39 PM
  Release 9.1.1 || Microcode 15.3 || Runtime 15.7 || SF 4.41 || LIAR/C 4.118
  Edwin 3.116
;Loading "ch4-mceval.scm"...

;;; M-Eval input:
(define (fact n) (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(self-evaluating (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(variable (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(quoted (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(assignment? (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(definition? (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(eval-definition (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(definition-value (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))
(make-lambda (n) ((if (= n 0) 1 (* n (fact (- n 1))))))
(eval (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(self-evaluating (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(variable (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(quoted (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(assignment? (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(definition? (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(if? (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(lambda? (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(lambda-body (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(lambda-parameters (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))
(definition-variable (define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))))

;;; M-Eval value:
ok

;;; M-Eval input:
(fact 3)
(eval (fact 3))
(self-evaluating (fact 3))
(variable (fact 3))
(quoted (fact 3))
(assignment? (fact 3))
(definition? (fact 3))
(if? (fact 3))
(lambda? (fact 3))
(begin? (fact 3))
(application? (fact 3))
(operator (fact 3))
(list-of-values (3))
(list-of-values ())
(eval 3)
(self-evaluating 3)
(operator (fact 3))
(eval fact)
(self-evaluating fact)
(variable fact)
(apply (3))
(eval-sequence ((if (= n 0) 1 (* n (fact (- n 1))))))
(last-exp? ((if (= n 0) 1 (* n (fact (- n 1))))))
(first-exp ((if (= n 0) 1 (* n (fact (- n 1))))))
(eval (if (= n 0) 1 (* n (fact (- n 1)))))
(self-evaluating (if (= n 0) 1 (* n (fact (- n 1)))))
(variable (if (= n 0) 1 (* n (fact (- n 1)))))
(quoted (if (= n 0) 1 (* n (fact (- n 1)))))
(assignment? (if (= n 0) 1 (* n (fact (- n 1)))))
(definition? (if (= n 0) 1 (* n (fact (- n 1)))))
(if? (if (= n 0) 1 (* n (fact (- n 1)))))
(eval-if (if (= n 0) 1 (* n (fact (- n 1)))))
(if-predicate (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (= n 0))
(self-evaluating (= n 0))
(variable (= n 0))
(quoted (= n 0))
(assignment? (= n 0))
(definition? (= n 0))
(if? (= n 0))
(lambda? (= n 0))
(begin? (= n 0))
(application? (= n 0))
(operator (= n 0))
(list-of-values (n 0))
(list-of-values (0))
(list-of-values ())
(eval 0)
(self-evaluating 0)
(eval n)
(self-evaluating n)
(variable n)
(operator (= n 0))
(eval =)
(self-evaluating =)
(variable =)
(apply (3 0))
(true? #f)
(if-alternative (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (* n (fact (- n 1))))
(self-evaluating (* n (fact (- n 1))))
(variable (* n (fact (- n 1))))
(quoted (* n (fact (- n 1))))
(assignment? (* n (fact (- n 1))))
(definition? (* n (fact (- n 1))))
(if? (* n (fact (- n 1))))
(lambda? (* n (fact (- n 1))))
(begin? (* n (fact (- n 1))))
(application? (* n (fact (- n 1))))
(operator (* n (fact (- n 1))))
(list-of-values (n (fact (- n 1))))
(list-of-values ((fact (- n 1))))
(list-of-values ())
(eval (fact (- n 1)))
(self-evaluating (fact (- n 1)))
(variable (fact (- n 1)))
(quoted (fact (- n 1)))
(assignment? (fact (- n 1)))
(definition? (fact (- n 1)))
(if? (fact (- n 1)))
(lambda? (fact (- n 1)))
(begin? (fact (- n 1)))
(application? (fact (- n 1)))
(operator (fact (- n 1)))
(list-of-values ((- n 1)))
(list-of-values ())
(eval (- n 1))
(self-evaluating (- n 1))
(variable (- n 1))
(quoted (- n 1))
(assignment? (- n 1))
(definition? (- n 1))
(if? (- n 1))
(lambda? (- n 1))
(begin? (- n 1))
(application? (- n 1))
(operator (- n 1))
(list-of-values (n 1))
(list-of-values (1))
(list-of-values ())
(eval 1)
(self-evaluating 1)
(eval n)
(self-evaluating n)
(variable n)
(operator (- n 1))
(eval -)
(self-evaluating -)
(variable -)
(apply (3 1))
(operator (fact (- n 1)))
(eval fact)
(self-evaluating fact)
(variable fact)
(apply (2))
(eval-sequence ((if (= n 0) 1 (* n (fact (- n 1))))))
(last-exp? ((if (= n 0) 1 (* n (fact (- n 1))))))
(first-exp ((if (= n 0) 1 (* n (fact (- n 1))))))
(eval (if (= n 0) 1 (* n (fact (- n 1)))))
(self-evaluating (if (= n 0) 1 (* n (fact (- n 1)))))
(variable (if (= n 0) 1 (* n (fact (- n 1)))))
(quoted (if (= n 0) 1 (* n (fact (- n 1)))))
(assignment? (if (= n 0) 1 (* n (fact (- n 1)))))
(definition? (if (= n 0) 1 (* n (fact (- n 1)))))
(if? (if (= n 0) 1 (* n (fact (- n 1)))))
(eval-if (if (= n 0) 1 (* n (fact (- n 1)))))
(if-predicate (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (= n 0))
(self-evaluating (= n 0))
(variable (= n 0))
(quoted (= n 0))
(assignment? (= n 0))
(definition? (= n 0))
(if? (= n 0))
(lambda? (= n 0))
(begin? (= n 0))
(application? (= n 0))
(operator (= n 0))
(list-of-values (n 0))
(list-of-values (0))
(list-of-values ())
(eval 0)
(self-evaluating 0)
(eval n)
(self-evaluating n)
(variable n)
(operator (= n 0))
(eval =)
(self-evaluating =)
(variable =)
(apply (2 0))
(true? #f)
(if-alternative (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (* n (fact (- n 1))))
(self-evaluating (* n (fact (- n 1))))
(variable (* n (fact (- n 1))))
(quoted (* n (fact (- n 1))))
(assignment? (* n (fact (- n 1))))
(definition? (* n (fact (- n 1))))
(if? (* n (fact (- n 1))))
(lambda? (* n (fact (- n 1))))
(begin? (* n (fact (- n 1))))
(application? (* n (fact (- n 1))))
(operator (* n (fact (- n 1))))
(list-of-values (n (fact (- n 1))))
(list-of-values ((fact (- n 1))))
(list-of-values ())
(eval (fact (- n 1)))
(self-evaluating (fact (- n 1)))
(variable (fact (- n 1)))
(quoted (fact (- n 1)))
(assignment? (fact (- n 1)))
(definition? (fact (- n 1)))
(if? (fact (- n 1)))
(lambda? (fact (- n 1)))
(begin? (fact (- n 1)))
(application? (fact (- n 1)))
(operator (fact (- n 1)))
(list-of-values ((- n 1)))
(list-of-values ())
(eval (- n 1))
(self-evaluating (- n 1))
(variable (- n 1))
(quoted (- n 1))
(assignment? (- n 1))
(definition? (- n 1))
(if? (- n 1))
(lambda? (- n 1))
(begin? (- n 1))
(application? (- n 1))
(operator (- n 1))
(list-of-values (n 1))
(list-of-values (1))
(list-of-values ())
(eval 1)
(self-evaluating 1)
(eval n)
(self-evaluating n)
(variable n)
(operator (- n 1))
(eval -)
(self-evaluating -)
(variable -)
(apply (2 1))
(operator (fact (- n 1)))
(eval fact)
(self-evaluating fact)
(variable fact)
(apply (1))
(eval-sequence ((if (= n 0) 1 (* n (fact (- n 1))))))
(last-exp? ((if (= n 0) 1 (* n (fact (- n 1))))))
(first-exp ((if (= n 0) 1 (* n (fact (- n 1))))))
(eval (if (= n 0) 1 (* n (fact (- n 1)))))
(self-evaluating (if (= n 0) 1 (* n (fact (- n 1)))))
(variable (if (= n 0) 1 (* n (fact (- n 1)))))
(quoted (if (= n 0) 1 (* n (fact (- n 1)))))
(assignment? (if (= n 0) 1 (* n (fact (- n 1)))))
(definition? (if (= n 0) 1 (* n (fact (- n 1)))))
(if? (if (= n 0) 1 (* n (fact (- n 1)))))
(eval-if (if (= n 0) 1 (* n (fact (- n 1)))))
(if-predicate (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (= n 0))
(self-evaluating (= n 0))
(variable (= n 0))
(quoted (= n 0))
(assignment? (= n 0))
(definition? (= n 0))
(if? (= n 0))
(lambda? (= n 0))
(begin? (= n 0))
(application? (= n 0))
(operator (= n 0))
(list-of-values (n 0))
(list-of-values (0))
(list-of-values ())
(eval 0)
(self-evaluating 0)
(eval n)
(self-evaluating n)
(variable n)
(operator (= n 0))
(eval =)
(self-evaluating =)
(variable =)
(apply (1 0))
(true? #f)
(if-alternative (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (* n (fact (- n 1))))
(self-evaluating (* n (fact (- n 1))))
(variable (* n (fact (- n 1))))
(quoted (* n (fact (- n 1))))
(assignment? (* n (fact (- n 1))))
(definition? (* n (fact (- n 1))))
(if? (* n (fact (- n 1))))
(lambda? (* n (fact (- n 1))))
(begin? (* n (fact (- n 1))))
(application? (* n (fact (- n 1))))
(operator (* n (fact (- n 1))))
(list-of-values (n (fact (- n 1))))
(list-of-values ((fact (- n 1))))
(list-of-values ())
(eval (fact (- n 1)))
(self-evaluating (fact (- n 1)))
(variable (fact (- n 1)))
(quoted (fact (- n 1)))
(assignment? (fact (- n 1)))
(definition? (fact (- n 1)))
(if? (fact (- n 1)))
(lambda? (fact (- n 1)))
(begin? (fact (- n 1)))
(application? (fact (- n 1)))
(operator (fact (- n 1)))
(list-of-values ((- n 1)))
(list-of-values ())
(eval (- n 1))
(self-evaluating (- n 1))
(variable (- n 1))
(quoted (- n 1))
(assignment? (- n 1))
(definition? (- n 1))
(if? (- n 1))
(lambda? (- n 1))
(begin? (- n 1))
(application? (- n 1))
(operator (- n 1))
(list-of-values (n 1))
(list-of-values (1))
(list-of-values ())
(eval 1)
(self-evaluating 1)
(eval n)
(self-evaluating n)
(variable n)
(operator (- n 1))
(eval -)
(self-evaluating -)
(variable -)
(apply (1 1))
(operator (fact (- n 1)))
(eval fact)
(self-evaluating fact)
(variable fact)
(apply (0))
(eval-sequence ((if (= n 0) 1 (* n (fact (- n 1))))))
(last-exp? ((if (= n 0) 1 (* n (fact (- n 1))))))
(first-exp ((if (= n 0) 1 (* n (fact (- n 1))))))
(eval (if (= n 0) 1 (* n (fact (- n 1)))))
(self-evaluating (if (= n 0) 1 (* n (fact (- n 1)))))
(variable (if (= n 0) 1 (* n (fact (- n 1)))))
(quoted (if (= n 0) 1 (* n (fact (- n 1)))))
(assignment? (if (= n 0) 1 (* n (fact (- n 1)))))
(definition? (if (= n 0) 1 (* n (fact (- n 1)))))
(if? (if (= n 0) 1 (* n (fact (- n 1)))))
(eval-if (if (= n 0) 1 (* n (fact (- n 1)))))
(if-predicate (if (= n 0) 1 (* n (fact (- n 1)))))
(eval (= n 0))
(self-evaluating (= n 0))
(variable (= n 0))
(quoted (= n 0))
(assignment? (= n 0))
(definition? (= n 0))
(if? (= n 0))
(lambda? (= n 0))
(begin? (= n 0))
(application? (= n 0))
(operator (= n 0))
(list-of-values (n 0))
(list-of-values (0))
(list-of-values ())
(eval 0)
(self-evaluating 0)
(eval n)
(self-evaluating n)
(variable n)
(operator (= n 0))
(eval =)
(self-evaluating =)
(variable =)
(apply (0 0))
(true? #t)
(if-consequent (if (= n 0) 1 (* n (fact (- n 1)))))
(eval 1)
(self-evaluating 1)
(eval n)
(self-evaluating n)
(variable n)
(operator (* n (fact (- n 1))))
(eval *)
(self-evaluating *)
(variable *)
(apply (1 1))
(eval n)
(self-evaluating n)
(variable n)
(operator (* n (fact (- n 1))))
(eval *)
(self-evaluating *)
(variable *)
(apply (2 1))
(eval n)
(self-evaluating n)
(variable n)
(operator (* n (fact (- n 1))))
(eval *)
(self-evaluating *)
(variable *)
(apply (3 2))

;;; M-Eval value:
6
